// Generated by CoffeeScript 1.12.7
(function() {
  var FocusSelector, NormalMode, NormalModeCommands, enterNormalMode, findAndFollowLink, findAndFollowRel, followLink, root, textInputXPath,
    extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  NormalMode = (function(superClass) {
    extend1(NormalMode, superClass);

    function NormalMode(options) {
      var defaults;
      if (options == null) {
        options = {};
      }
      defaults = {
        name: "normal",
        indicator: false,
        commandHandler: this.commandHandler.bind(this)
      };
      NormalMode.__super__.constructor.call(this, extend(defaults, options));
      chrome.storage.local.get("normalModeKeyStateMapping", (function(_this) {
        return function(items) {
          return _this.setKeyMapping(items.normalModeKeyStateMapping);
        };
      })(this));
      chrome.storage.onChanged.addListener((function(_this) {
        return function(changes, area) {
          var ref;
          if (area === "local" && ((ref = changes.normalModeKeyStateMapping) != null ? ref.newValue : void 0)) {
            return _this.setKeyMapping(changes.normalModeKeyStateMapping.newValue);
          }
        };
      })(this));
    }

    NormalMode.prototype.commandHandler = function(arg) {
      var count, ref, registryEntry, sourceFrameId;
      registryEntry = arg.command, count = arg.count;
      count *= (ref = registryEntry.options.count) != null ? ref : 1;
      if (registryEntry.noRepeat) {
        count = 1;
      }
      if ((registryEntry.repeatLimit != null) && registryEntry.repeatLimit < count) {
        if (!confirm("You have asked Vimium to perform " + count + " repetitions of the command: " + registryEntry.description + ".\n\nAre you sure you want to continue?")) {
          return;
        }
      }
      if (registryEntry.topFrame) {
        sourceFrameId = window.isVimiumUIComponent ? 0 : frameId;
        return chrome.runtime.sendMessage({
          handler: "sendMessageToFrames",
          message: {
            name: "runInTopFrame",
            sourceFrameId: sourceFrameId,
            registryEntry: registryEntry
          }
        });
      } else if (registryEntry.background) {
        return chrome.runtime.sendMessage({
          handler: "runBackgroundCommand",
          registryEntry: registryEntry,
          count: count
        });
      } else {
        return NormalModeCommands[registryEntry.command](count, {
          registryEntry: registryEntry
        });
      }
    };

    return NormalMode;

  })(KeyHandlerMode);

  enterNormalMode = function(count) {
    return new NormalMode({
      indicator: "Normal mode (pass keys disabled)",
      exitOnEscape: true,
      singleton: "enterNormalMode",
      count: count
    });
  };

  NormalModeCommands = {
    scrollToBottom: function() {
      Marks.setPreviousPosition();
      return Scroller.scrollTo("y", "max");
    },
    scrollToTop: function(count) {
      Marks.setPreviousPosition();
      return Scroller.scrollTo("y", (count - 1) * Settings.get("scrollStepSize"));
    },
    scrollToLeft: function() {
      return Scroller.scrollTo("x", 0);
    },
    scrollToRight: function() {
      return Scroller.scrollTo("x", "max");
    },
    scrollUp: function(count) {
      return Scroller.scrollBy("y", -1 * Settings.get("scrollStepSize") * count);
    },
    scrollDown: function(count) {
      return Scroller.scrollBy("y", Settings.get("scrollStepSize") * count);
    },
    scrollPageUp: function(count) {
      return Scroller.scrollBy("y", "viewSize", -1 / 2 * count);
    },
    scrollPageDown: function(count) {
      return Scroller.scrollBy("y", "viewSize", 1 / 2 * count);
    },
    scrollFullPageUp: function(count) {
      return Scroller.scrollBy("y", "viewSize", -1 * count);
    },
    scrollFullPageDown: function(count) {
      return Scroller.scrollBy("y", "viewSize", 1 * count);
    },
    scrollLeft: function(count) {
      return Scroller.scrollBy("x", -1 * Settings.get("scrollStepSize") * count);
    },
    scrollRight: function(count) {
      return Scroller.scrollBy("x", Settings.get("scrollStepSize") * count);
    },
    goBack: function(count) {
      return history.go(-count);
    },
    goForward: function(count) {
      return history.go(count);
    },
    goUp: function(count) {
      var url, urlsplit;
      url = window.location.href;
      if (url[url.length - 1] === "/") {
        url = url.substring(0, url.length - 1);
      }
      urlsplit = url.split("/");
      if (urlsplit.length > 3) {
        urlsplit = urlsplit.slice(0, Math.max(3, urlsplit.length - count));
        return window.location.href = urlsplit.join('/');
      }
    },
    goToRoot: function() {
      return window.location.href = window.location.origin;
    },
    toggleViewSource: function() {
      return chrome.runtime.sendMessage({
        handler: "getCurrentTabUrl"
      }, function(url) {
        if (url.substr(0, 12) === "view-source:") {
          url = url.substr(12, url.length - 12);
        } else {
          url = "view-source:" + url;
        }
        return chrome.runtime.sendMessage({
          handler: "openUrlInNewTab",
          url: url
        });
      });
    },
    copyCurrentUrl: function() {
      return chrome.runtime.sendMessage({
        handler: "getCurrentTabUrl"
      }, function(url) {
        HUD.copyToClipboard(url);
        if (28 < url.length) {
          url = url.slice(0, 26) + "....";
        }
        return HUD.showForDuration("Yanked " + url, 2000);
      });
    },
    openCopiedUrlInNewTab: function(count) {
      return HUD.pasteFromClipboard(function(url) {
        return chrome.runtime.sendMessage({
          handler: "openUrlInNewTab",
          url: url,
          count: count
        });
      });
    },
    openCopiedUrlInCurrentTab: function() {
      return HUD.pasteFromClipboard(function(url) {
        return chrome.runtime.sendMessage({
          handler: "openUrlInCurrentTab",
          url: url
        });
      });
    },
    enterInsertMode: function() {
      return new InsertMode({
        global: true,
        exitOnFocus: true
      });
    },
    enterVisualMode: function() {
      return new VisualMode({
        userLaunchedMode: true
      });
    },
    enterVisualLineMode: function() {
      return new VisualLineMode({
        userLaunchedMode: true
      });
    },
    enterFindMode: function() {
      Marks.setPreviousPosition();
      return new FindMode();
    },
    performFind: function(count) {
      var j, ref, results;
      results = [];
      for (j = 0, ref = count; j < ref; j += 1) {
        results.push(FindMode.findNext(false));
      }
      return results;
    },
    performBackwardsFind: function(count) {
      var j, ref, results;
      results = [];
      for (j = 0, ref = count; j < ref; j += 1) {
        results.push(FindMode.findNext(true));
      }
      return results;
    },
    mainFrame: function() {
      return focusThisFrame({
        highlight: true,
        forceFocusThisFrame: true
      });
    },
    showHelp: function(sourceFrameId) {
      return HelpDialog.toggle({
        sourceFrameId: sourceFrameId,
        showAllCommandDetails: false
      });
    },
    passNextKey: function(count, options) {
      if (options.registryEntry.options.normal) {
        return enterNormalMode(count);
      } else {
        return new PassNextKeyMode(count);
      }
    },
    goPrevious: function() {
      var previousPatterns, previousStrings;
      previousPatterns = Settings.get("previousPatterns") || "";
      previousStrings = previousPatterns.split(",").filter(function(s) {
        return s.trim().length;
      });
      return findAndFollowRel("prev") || findAndFollowLink(previousStrings);
    },
    goNext: function() {
      var nextPatterns, nextStrings;
      nextPatterns = Settings.get("nextPatterns") || "";
      nextStrings = nextPatterns.split(",").filter(function(s) {
        return s.trim().length;
      });
      return findAndFollowRel("next") || findAndFollowLink(nextStrings);
    },
    focusInput: function(count) {
      var element, elements, hint, hints, i, recentlyFocusedElement, resultSet, selectedInputIndex, tuple, visibleInputs;
      resultSet = DomUtils.evaluateXPath(textInputXPath, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE);
      visibleInputs = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = resultSet.snapshotLength; j < ref; i = j += 1) {
          element = resultSet.snapshotItem(i);
          if (!DomUtils.getVisibleClientRect(element, true)) {
            continue;
          }
          results.push({
            element: element,
            index: i,
            rect: Rect.copy(element.getBoundingClientRect())
          });
        }
        return results;
      })();
      visibleInputs.sort(function(arg, arg1) {
        var element1, element2, i1, i2, tabDifference;
        element1 = arg.element, i1 = arg.index;
        element2 = arg1.element, i2 = arg1.index;
        if (element1.tabIndex > 0) {
          if (element2.tabIndex > 0) {
            tabDifference = element1.tabIndex - element2.tabIndex;
            if (tabDifference !== 0) {
              return tabDifference;
            } else {
              return i1 - i2;
            }
          } else {
            return -1;
          }
        } else if (element2.tabIndex > 0) {
          return 1;
        } else {
          return i1 - i2;
        }
      });
      if (visibleInputs.length === 0) {
        HUD.showForDuration("There are no inputs to focus.", 1000);
        return;
      }
      recentlyFocusedElement = lastFocusedInput();
      selectedInputIndex = count === 1 ? (elements = visibleInputs.map(function(visibleInput) {
        return visibleInput.element;
      }), Math.max(0, elements.indexOf(recentlyFocusedElement))) : Math.min(count, visibleInputs.length) - 1;
      hints = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = visibleInputs.length; j < len; j++) {
          tuple = visibleInputs[j];
          hint = DomUtils.createElement("div");
          hint.className = "vimiumReset internalVimiumInputHint vimiumInputHint";
          hint.style.left = (tuple.rect.left - 1) + window.scrollX + "px";
          hint.style.top = (tuple.rect.top - 1) + window.scrollY + "px";
          hint.style.width = tuple.rect.width + "px";
          hint.style.height = tuple.rect.height + "px";
          results.push(hint);
        }
        return results;
      })();
      return new FocusSelector(hints, visibleInputs, selectedInputIndex);
    }
  };

  if (typeof LinkHints !== "undefined" && LinkHints !== null) {
    extend(NormalModeCommands, {
      "LinkHints.activateMode": LinkHints.activateMode.bind(LinkHints),
      "LinkHints.activateModeToOpenInNewTab": LinkHints.activateModeToOpenInNewTab.bind(LinkHints),
      "LinkHints.activateModeToOpenInNewForegroundTab": LinkHints.activateModeToOpenInNewForegroundTab.bind(LinkHints),
      "LinkHints.activateModeWithQueue": LinkHints.activateModeWithQueue.bind(LinkHints),
      "LinkHints.activateModeToOpenIncognito": LinkHints.activateModeToOpenIncognito.bind(LinkHints),
      "LinkHints.activateModeToDownloadLink": LinkHints.activateModeToDownloadLink.bind(LinkHints),
      "LinkHints.activateModeToCopyLinkUrl": LinkHints.activateModeToCopyLinkUrl.bind(LinkHints)
    });
  }

  if (typeof Vomnibar !== "undefined" && Vomnibar !== null) {
    extend(NormalModeCommands, {
      "Vomnibar.activate": Vomnibar.activate.bind(Vomnibar),
      "Vomnibar.activateInNewTab": Vomnibar.activateInNewTab.bind(Vomnibar),
      "Vomnibar.activateTabSelection": Vomnibar.activateTabSelection.bind(Vomnibar),
      "Vomnibar.activateBookmarks": Vomnibar.activateBookmarks.bind(Vomnibar),
      "Vomnibar.activateBookmarksInNewTab": Vomnibar.activateBookmarksInNewTab.bind(Vomnibar),
      "Vomnibar.activateEditUrl": Vomnibar.activateEditUrl.bind(Vomnibar),
      "Vomnibar.activateEditUrlInNewTab": Vomnibar.activateEditUrlInNewTab.bind(Vomnibar)
    });
  }

  if (typeof Marks !== "undefined" && Marks !== null) {
    extend(NormalModeCommands, {
      "Marks.activateCreateMode": Marks.activateCreateMode.bind(Marks),
      "Marks.activateGotoMode": Marks.activateGotoMode.bind(Marks)
    });
  }

  textInputXPath = (function() {
    var inputElements, textInputTypes;
    textInputTypes = ["text", "search", "email", "url", "number", "password", "date", "tel"];
    inputElements = [
      "input[" + "(" + textInputTypes.map(function(type) {
        return '@type="' + type + '"';
      }).join(" or ") + "or not(@type))" + " and not(@disabled or @readonly)]", "textarea", "*[@contenteditable='' or translate(@contenteditable, 'TRUE', 'true')='true']"
    ];
    return typeof DomUtils !== "undefined" && DomUtils !== null ? DomUtils.makeXPath(inputElements) : void 0;
  })();

  followLink = function(linkElement) {
    if (linkElement.nodeName.toLowerCase() === "link") {
      return window.location.href = linkElement.href;
    } else {
      linkElement.scrollIntoView();
      return DomUtils.simulateClick(linkElement);
    }
  };

  findAndFollowLink = function(linkStrings) {
    var boundingClientRect, candidateLink, candidateLinks, computedStyle, exactWordRegex, i, j, k, l, len, len1, len2, len3, link, linkMatches, linkString, links, linksXPath, m, n, ref, ref1;
    linksXPath = DomUtils.makeXPath(["a", "*[@onclick or @role='link' or contains(@class, 'button')]"]);
    links = DomUtils.evaluateXPath(linksXPath, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE);
    candidateLinks = [];
    for (i = j = ref = links.snapshotLength - 1; j >= 0; i = j += -1) {
      link = links.snapshotItem(i);
      boundingClientRect = link.getBoundingClientRect();
      if (boundingClientRect.width === 0 || boundingClientRect.height === 0) {
        continue;
      }
      computedStyle = window.getComputedStyle(link, null);
      if (computedStyle.getPropertyValue("visibility") !== "visible" || computedStyle.getPropertyValue("display") === "none") {
        continue;
      }
      linkMatches = false;
      for (k = 0, len = linkStrings.length; k < len; k++) {
        linkString = linkStrings[k];
        if (link.innerText.toLowerCase().indexOf(linkString) !== -1 || 0 <= ((ref1 = link.value) != null ? typeof ref1.indexOf === "function" ? ref1.indexOf(linkString) : void 0 : void 0)) {
          linkMatches = true;
          break;
        }
      }
      if (!linkMatches) {
        continue;
      }
      candidateLinks.push(link);
    }
    if (candidateLinks.length === 0) {
      return;
    }
    for (l = 0, len1 = candidateLinks.length; l < len1; l++) {
      link = candidateLinks[l];
      link.wordCount = link.innerText.trim().split(/\s+/).length;
    }
    candidateLinks.forEach(function(a, i) {
      return a.originalIndex = i;
    });
    candidateLinks = candidateLinks.sort(function(a, b) {
      if (a.wordCount === b.wordCount) {
        return a.originalIndex - b.originalIndex;
      } else {
        return a.wordCount - b.wordCount;
      }
    }).filter(function(a) {
      return a.wordCount <= candidateLinks[0].wordCount + 1;
    });
    for (m = 0, len2 = linkStrings.length; m < len2; m++) {
      linkString = linkStrings[m];
      exactWordRegex = /\b/.test(linkString[0]) || /\b/.test(linkString[linkString.length - 1]) ? new RegExp("\\b" + linkString + "\\b", "i") : new RegExp(linkString, "i");
      for (n = 0, len3 = candidateLinks.length; n < len3; n++) {
        candidateLink = candidateLinks[n];
        if (exactWordRegex.test(candidateLink.innerText) || (candidateLink.value && exactWordRegex.test(candidateLink.value))) {
          followLink(candidateLink);
          return true;
        }
      }
    }
    return false;
  };

  findAndFollowRel = function(value) {
    var element, elements, j, k, len, len1, relTags, tag;
    relTags = ["link", "a", "area"];
    for (j = 0, len = relTags.length; j < len; j++) {
      tag = relTags[j];
      elements = document.getElementsByTagName(tag);
      for (k = 0, len1 = elements.length; k < len1; k++) {
        element = elements[k];
        if (element.hasAttribute("rel") && element.rel.toLowerCase() === value) {
          followLink(element);
          return true;
        }
      }
    }
  };

  FocusSelector = (function(superClass) {
    extend1(FocusSelector, superClass);

    function FocusSelector(hints, visibleInputs, selectedInputIndex) {
      FocusSelector.__super__.constructor.call(this, {
        name: "focus-selector",
        exitOnClick: true,
        keydown: (function(_this) {
          return function(event) {
            if (event.key === "Tab") {
              hints[selectedInputIndex].classList.remove('internalVimiumSelectedInputHint');
              selectedInputIndex += hints.length + (event.shiftKey ? -1 : 1);
              selectedInputIndex %= hints.length;
              hints[selectedInputIndex].classList.add('internalVimiumSelectedInputHint');
              DomUtils.simulateSelect(visibleInputs[selectedInputIndex].element);
              return _this.suppressEvent;
            } else if (event.key !== "Shift") {
              _this.exit();
              return _this.restartBubbling;
            }
          };
        })(this)
      });
      this.hintContainingDiv = DomUtils.addElementList(hints, {
        id: "vimiumInputMarkerContainer",
        className: "vimiumReset"
      });
      DomUtils.simulateSelect(visibleInputs[selectedInputIndex].element);
      if (visibleInputs.length === 1) {
        this.exit();
        return;
      } else {
        hints[selectedInputIndex].classList.add('internalVimiumSelectedInputHint');
      }
    }

    FocusSelector.prototype.exit = function() {
      FocusSelector.__super__.exit.call(this);
      DomUtils.removeElement(this.hintContainingDiv);
      if (document.activeElement && DomUtils.isEditable(document.activeElement)) {
        return new InsertMode({
          singleton: "post-find-mode/focus-input",
          targetElement: document.activeElement,
          indicator: false
        });
      }
    };

    return FocusSelector;

  })(Mode);

  root = typeof exports !== "undefined" && exports !== null ? exports : (window.root != null ? window.root : window.root = {});

  root.NormalMode = NormalMode;

  root.NormalModeCommands = NormalModeCommands;

  if (typeof exports === "undefined" || exports === null) {
    extend(window, root);
  }

}).call(this);
